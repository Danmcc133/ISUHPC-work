#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#define N 6 // Unlike the previous script, this is able to be run for a general NxN matrix

// This function generates a random NxN lower triangular matrix with 1's on the diagonal
// The output is a random matrix witht he above paramters
void matrixgen(double L[6][6]) {
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) {
            if (i < j) {
                L[i][j] = 0.0;
            } else if (i == j) {
                L[i][j] = 1.0;
            } else {
                L[i][j] = (double)rand() / RAND_MAX;
            }
        }
    }
}

// This function defines matrix multiplication between two NxN matrices
// The input is two NxN matrices
// The output is the product of the input matrices, also a NxN matrix
void matrixmult(double A[N][N], double B[N][N], double C[N][N]) {
    for (int i = 0; i < 6; i++) {
        for (int j = 0; j < 6; j++) {
            C[i][j] = 0.0;
            for (int k = 0; k < 6; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

// This function "prints" an input matrix
// The input is a mtrix and a given name
// The out put is "name" = matrix
void print_matrix(double matrix[N][N], const char* name) {
    printf("%s = \n", name);
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            printf("%f ", matrix[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

// This function applies QR factorization to a matrix A using Gram-Schmidt 
// The input is the matrix A
// The output is both the Q and R matrices generated by the factorization
void qr_factor(double A[N][N], double Q[N][N], double R[N][N], int n) {
    for (int k = 0; k < n; k++) {
        double norm = 0.0;
        for (int i = 0; i < n; i++) {
            norm += A[i][k] * A[i][k];
        }
        R[k][k] = sqrt(norm); // This constructs R[k][k]
        
        for (int i = 0; i < n; i++) {
            Q[i][k] = A[i][k] / R[k][k]; // This constructs Q[:][k]
        }
        
        for (int j = k + 1; j < n; j++) {
            R[k][j] = 0.0;
            for (int i = 0; i < n; i++) {
                R[k][j] += Q[i][k] * A[i][j]; // This constructs R[k][j]
            }
            for (int i = 0; i < n; i++) {
                A[i][j] -= Q[i][k] * R[k][j]; // This updates A[:][j]
            }
        }
    }
}


// This function generates a NxN (in this case 6x6) lower triangular matrix L
// with 1's on the diagonal and random numbers between 0 and 1 below the diagonal, as well as its transpose
// It then multiplies these matrices to generate a new matrix A
// Finally, it applies QR factorization to A and then prints the diagonal entries of R i.e. the eigenvalues of A
// The input is the dimension of the matrix 
// The output is a list of the eigenvalues of the matrix A = LL^T
int main() {
    double L[N][N] = {0};
    double A[N][N] = {0};
    double Q[N][N] = {0};
    double R[N][N] = {0};
    double eigenvalues[N] = {0};

    matrixgen(L); // This generates the matrix L
    
    double LT[N][N];  // This calculates the transpose of L
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            LT[j][i] = L[i][j];

    matrixmult(L, LT, A); // This calculates the product of L and L^T

    print_matrix(A, "A"); // This prints the matrix A

    qr_factor(A, Q, R, N); // This finds the QR factorization of A

    printf("Eigenvalues of A:\n"); 
    for (int i = 0; i < N; ++i) {
        printf("%f\n", R[i][i]); // The eigenvalues are the diagonal entries of R
    }

    return 0;
}